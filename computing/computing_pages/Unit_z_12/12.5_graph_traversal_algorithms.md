noted : 12/09/23

# Graph Traversal Algorithms

There are 2 ways of traversing a graph:

| Term          | Def                                                                                      |
| :------------ | :--------------------------------------------------------------------------------------- |
| Depth-first   | go as far as you can down a path before backtracking and going down the next path        |
| breadth-first | explore all neighbours of current vertex, then the neighbours of each of those verticies |

## Depth first

Depth first algorithms use a stack to keep track of the last node visited, and a list to hold the names of nodes that have been visited.

Has several applications:

-   Job-scheduling
-   Finding path between 2 verticies
-   Soling pzzels such as navigating a maze

### Walkthrough

Here is the dictionary data structure for the graph:

```
GRAPH = {
    "A": ["B", "D", "E"],
    "B": ["A", "C", "D"],
    "C": ["B", "G"],
    "D": ["A", "B", "E", "F"],
    "E": ["A", "D"],
    "F": ["D"],
    "G": ["C"],
}
```

Each key represents a node. The value pair represents the links. So A is linked to B, D, and E.

---

We start with an empty stack, and list.

![Step 1 diagram of Depth First Algorithm](../../computing_images/aDepthfirst.png)

---

1. Visit the first node: `A`
2. Then, add `A` to the visited list and mark it as visited on the graph

![Step 2 diagram of Depth First Algorithm](../../computing_images/bDepth%20First%20walkthrough.png)

---

3. Push `A` onto the stack
4. Next, visit the next unvisited neighbour: `B`
5. Then, add `B` to the visited list and mark it as visited on the graph

![Step 3 diagram of Depth First Algorithm](../../computing_images/CdEPTHFIRST.png)

---

6. Push `B` onto the stack
7. Next, visit the next unvisited neighbour: `C`
8. Then, add `C` to the visited list and mark it as visited on the graph

![Step 4 diagram of Depth First Algorithm](../../computing_images/dDepthFirst.png)

---

9. Push `C` onto the stack
10. Next, visit the next unvisited neighbour: `G`
11. Then, add `G` tp the visited list and mark it as visited on the graph

![Step 5 diagram of Depth First Algorithm](../../computing_images/edepthfirst.png)

---

12. From `G`, there are no unvisited nodes so we backtrack to `C`
13. Pop `C` off the stack and return to `C`

![Step 6 diagram of Depth First Algorithm](../../computing_images/fdepthjfirst.png)

---

14. From `C`, there are no unvisited nodes so we backtrack again to `B`
15. Pop `B` off the stack and return to `B`

![Step 7 diagram of Depth First Algorithm](../../computing_images/gdepthfirst.png)

---

Now that we have backtracked to `B`, there are unvisited neighbouring nodes: `D`

16. Push `B` back onto the stack
17. Next, visit the next unvisited neighbour: `D`
18. Then, add `D` to the visited list and mark it as visited on the graph

![Step 8 diagram of Depth First Algorithm](../../computing_images//hdepthfirst.png)

---

19. Push `D` onto the stack
20. Next, vist the next unvisited neighbour: `E`
21. Then, add `E` to the visited list and mark it as visited on the graph

![Step 9 diagram of Depth First Algorithm](../../computing_images/idepthfirst.png)

---

22. From `E`, there are no unvisited nodes so we backtrack to `D`
23. Pop `D` off the stack and return to `D`

![Step 10 diagram of Depth First Algorithm](../../computing_images/jdepthfirst.png)

---

Now that we have backtracked to `D`, there are unvisited neighbouring nodes: `F`

24. Push `D` back onto the stack
25. Next, visit the next unvisited neighbour: `F`
26. Then, add `F` to the visited list and mark it as visited on the graph

![Step 11 diagram of Depth First Algorithm](../../computing_images/ldepthfirst.png)

---

27. At `F`, all neighbouring nodes have been visited, so we pop `D` and backtrack to `B`

![Step 12 diagram of Depth First Algorithm](../../computing_images/mdepthfirst.png)

---

28. At `D`, all neighbouring nodes have been visited, so we pop `B` and backtrack to `A`

![Step 13 diagram of Depth First Algorithm](../../computing_images/ndepthfirst.png)

---

28. At `B`, all neighbouring nodes have been visited, so we pop `A`.

![Step 14 diagram of Depth First Algorithm](../../computing_images/odepthfirst.png)

### Algorithm For Depth First

```
function dfs(graph, currentVertex, visited)
    append currentVertex to list of visited nodes
    for vertex in graph[currentVertex]
        if vertex not in visited then
            dfs (graph, vertex, visited)
        endif
    next vertex
    return visited
endfunction
```

## Breadth first

Breadth first algorithms use a queue to keep track of nodes that we still have to visit, and a list to hold the names of nodes that have been visited.

Has several applications:

-   Finding the shortest path between two points
-   Web crawling
-   Finding all the friends of a given induvidual - Facebook

### Walkthrough

1. Append `A` to the queue, and mark it as pale green to show it has been queued.

![Step 1 diagram of Breadth First Algorithm](../../computing_images/zaBreadthFIrst.png)

---

2. Visit `A`, remove it from the queue.
3. Then, ammend `A` to the visitied list, and mark it as dark green to show it has been visited.

![Step 2 diagram of Breadth First Algorithm](../../computing_images/zbBreathdfirst.png)

---

4. Ammend Each of A's neighbouring nodes: `B`, `D`, `E` to the queue, and mark them as a pale green.

![Step 3 diagram of Breadth First Algorithm](../../computing_images/zcBreadthFirst.png)

---

5. Visit `B`, remove it from the queue.
6. Then ammend `B` to the visited list, and mark it as dark green.

![Step 4 diagram of Breadth First Algorithm](../../computing_images/zdBreadthFirst.png)

---

7. Ammend the remaining neighbour of `B`: `C` to the queue, and mark it as pale green.

![Step 5 diagram of Breadth First Algorithm](../../computing_images/zeBreadthFirst.png)

---

8. Visit `D`, remove it from the queue.
9. Then ammend `D` to the visited list, and mark it as dark green.

![Step 6 diagram of Breadth First Algorithm](../../computing_images/zfBreadthFirst.png)

---

10. Ammend the remaining neighbourt of `D`: `F` to the queue, and mark it as pale green.

![Step 6 diagram of Breadth First Algorithm](../../computing_images/zgBreadthFirst.png)

---

11. Visit `E`, remove it from the queue.
12. Then ammend `E` to the visited list, and mark it as dark green.

![Step 7 diagram of Breadth First Algorithm](../../computing_images/zhBreadthFirst.png)

---

13. Visit `C`, remove it from the queue.
14. Then ammend `C` to the visited list, and mark it as dark green.

![Step 8 diagram of Breadth First Algorithm](../../computing_images/ziBreadthFirst.png)

---

15. Ammend the remaining neighbour of `C`: `G` to the queue, and mark it as pale green.

![Step 9 diagram of Breadth First Algorithm](../../computing_images/zjBreadthFirst.png)

---

16. Visit `F`, remove it from the queue.
17. Then ammend `F` to the visited list, and mark it as dark green.

![Step 10 diagram of Breadth First Algorithm](../../computing_images/zkBreadthFirst.png)

---

18. Visit `G`, remove it from the queue.
19. Then ammend `G` to the visited list, and mark it as dark green.

![Step 11 diagram of Breadth First Algorithm](../../computing_images/zlBreadthFirst.png)
